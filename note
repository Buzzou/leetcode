用 栈 来模拟计算过程，遵循以下规则：

忽略空格
遍历字符串，按字符解析
遇到 数字：需要「解析完整数字」并累积（可能是多位数）。
遇到 加号/减号：
记录当前操作符的作用（加/减）。
遇到 - 时，转换 符号（相当于 -1 * num）。
遇到 左括号 (：
存储当前结果 和 操作符的作用，进入新的子表达式计算。
遇到 右括号 )：
弹出之前存储的结果 并 合并计算。
栈存储临时结果：
计算时遵循 左到右 的顺序，利用栈保存之前的计算状态，直到遇到 ) 结束子表达式。

关键优化点
多位数的处理：
由于输入可能是 "42" 这样的多位数，我们用 num = num * 10 + (c - '0') 来 累积计算。
减少不必要的 pop 操作：
用 sign 变量管理当前计算符号，减少额外数据结构。
sign 直接用于 result += sign * num 计算，不需要额外的存储符号栈。
避免 eval() 作弊：
不能使用 stoi() 解析整个字符串，否则无法处理括号嵌套。

这样的方法的空间复杂度：O(n)（由于哈希表存储了所有节点的映射）
========================================================================================================================
解题思路
题目要求将 n × n 的二进制矩阵转换为 四叉树（Quad Tree），四叉树是一种特殊的树结构，每个内部节点最多有 4 个子节点（topLeft、topRight、bottomLeft、bottomRight）。

我们可以使用递归来构建四叉树，具体步骤如下：

检查当前网格是否全为 0 或 1

如果当前网格的所有元素都相同（全部是 0 或 1），则这个网格是叶子节点，直接创建 Node(isLeaf=true, val=grid[i][j])，返回该节点。
将网格划分为四个子区域

如果网格不是全 0 或全 1，则将其划分为四个等大小的子网格：
topLeft（左上角）
topRight（右上角）
bottomLeft（左下角）
bottomRight（右下角）
递归地对这四个子区域调用 construct()，创建四个子节点。
返回当前节点

如果是叶子节点，则 isLeaf=true，且 topLeft、topRight、bottomLeft、bottomRight 均为 nullptr。
如果不是叶子节点，则 isLeaf=false，四个子区域的 Node* 作为当前节点的子节点。

复杂度分析
时间复杂度：O(n²)

最坏情况下，每个 1×1 网格都会成为叶子节点，递归遍历所有 n × n 元素，因此时间复杂度为 O(n²)。
空间复杂度：O(n²)

递归深度最多 log(n) 层，但最坏情况下，每个网格都需要创建一个 Node，所以空间复杂度为 O(n²)。
