用 栈 来模拟计算过程，遵循以下规则：

忽略空格
遍历字符串，按字符解析
遇到 数字：需要「解析完整数字」并累积（可能是多位数）。
遇到 加号/减号：
记录当前操作符的作用（加/减）。
遇到 - 时，转换 符号（相当于 -1 * num）。
遇到 左括号 (：
存储当前结果 和 操作符的作用，进入新的子表达式计算。
遇到 右括号 )：
弹出之前存储的结果 并 合并计算。
栈存储临时结果：
计算时遵循 左到右 的顺序，利用栈保存之前的计算状态，直到遇到 ) 结束子表达式。

关键优化点
多位数的处理：
由于输入可能是 "42" 这样的多位数，我们用 num = num * 10 + (c - '0') 来 累积计算。
减少不必要的 pop 操作：
用 sign 变量管理当前计算符号，减少额外数据结构。
sign 直接用于 result += sign * num 计算，不需要额外的存储符号栈。
避免 eval() 作弊：
不能使用 stoi() 解析整个字符串，否则无法处理括号嵌套。

这样的方法的空间复杂度：O(n)（由于哈希表存储了所有节点的映射）

1. get(key)
在 O(1) 时间内查找 key
如果 key 存在，移动到 cache 的表头（最近使用）
返回 value
时间复杂度：O(1)
2. put(key, value)
key 已存在：
直接更新 value
移动到 cache 的头部
key 不存在：
如果 capacity 超限，删除 链表尾部（最少使用的 key）
在 cache 头部插入新 key
时间复杂度：O(1)
